# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing

import pydantic

from ..core.datetime_utils import serialize_datetime
from .authorization_in_payments_entity import AuthorizationInPaymentsEntity
from .error_details_in_payments_entity import ErrorDetailsInPaymentsEntity
from .payment_method_in_payments_entity import PaymentMethodInPaymentsEntity
from .payments_entity_payment_status import PaymentsEntityPaymentStatus


class PaymentsEntity(pydantic.BaseModel):
    cf_payment_id: typing.Optional[int]
    order_id: typing.Optional[str]
    entity: typing.Optional[str]
    error_details: typing.Optional[ErrorDetailsInPaymentsEntity]
    is_captured: typing.Optional[bool]
    order_amount: typing.Optional[float] = pydantic.Field(
        description=("Order amount can be different from payment amount if you collect service fee from the customer\n")
    )
    payment_group: typing.Optional[str] = pydantic.Field(
        description=("Type of payment group. One of ['upi', 'card', 'app', 'netbanking', 'paylater', 'cardless_emi']\n")
    )
    payment_currency: typing.Optional[str]
    payment_amount: typing.Optional[float]
    payment_time: typing.Optional[str] = pydantic.Field(
        description=("This is the time when the payment was initiated\n")
    )
    payment_completion_time: typing.Optional[str] = pydantic.Field(
        description=("This is the time when the payment reaches its terminal state\n")
    )
    payment_status: typing.Optional[PaymentsEntityPaymentStatus] = pydantic.Field(
        description=(
            'The transaction status can be one of  ["SUCCESS", "NOT_ATTEMPTED", "FAILED", "USER_DROPPED", "VOID", "CANCELLED", "PENDING"]\n'
        )
    )
    payment_message: typing.Optional[str]
    bank_reference: typing.Optional[str]
    auth_id: typing.Optional[str]
    authorization: typing.Optional[AuthorizationInPaymentsEntity]
    payment_method: typing.Optional[PaymentMethodInPaymentsEntity]

    def json(self, **kwargs: typing.Any) -> str:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        return super().json(**kwargs_with_defaults)

    def dict(self, **kwargs: typing.Any) -> typing.Dict[str, typing.Any]:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        return super().dict(**kwargs_with_defaults)

    class Config:
        frozen = True
        json_encoders = {dt.datetime: serialize_datetime}
