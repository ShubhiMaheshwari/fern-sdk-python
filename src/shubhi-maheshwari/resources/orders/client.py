# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

import httpx
import pydantic

from ...core.api_error import ApiError as core_api_error_ApiError
from ...core.jsonable_encoder import jsonable_encoder
from ...core.remove_none_from_headers import remove_none_from_headers
from ...errors.internal_server_error import InternalServerError
from ...errors.too_many_requests_error import TooManyRequestsError
from ...errors.unauthorized_error import UnauthorizedError
from ...types.api_error import ApiError as types_api_error_ApiError
from ...types.authentication_error import AuthenticationError
from ...types.authorization_request_action import AuthorizationRequestAction
from ...types.customer_details import CustomerDetails
from ...types.order_meta import OrderMeta
from ...types.order_pay_request_payment_method import OrderPayRequestPaymentMethod
from ...types.order_pay_response import OrderPayResponse
from ...types.orders_entity import OrdersEntity
from ...types.payments_entity import PaymentsEntity
from ...types.rate_limit_error import RateLimitError
from ...types.terminal_details import TerminalDetails
from ...types.vendor_split import VendorSplit

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class OrdersClient:
    def __init__(
        self,
        *,
        environment: str,
        client_id: typing.Optional[str] = None,
        client_secret: typing.Optional[str] = None,
        api_version: typing.Optional[str] = None,
    ):
        self._environment = environment
        self.client_id = client_id
        self.client_secret = client_secret
        self.api_version = api_version

    def create_order(
        self,
        *,
        order_id: typing.Optional[str] = OMIT,
        order_amount: float,
        order_currency: str,
        customer_details: CustomerDetails,
        terminal: typing.Optional[TerminalDetails] = OMIT,
        order_meta: typing.Optional[OrderMeta] = OMIT,
        order_expiry_time: typing.Optional[str] = OMIT,
        order_note: typing.Optional[str] = OMIT,
        order_tags: typing.Optional[typing.Dict[str, str]] = OMIT,
        order_splits: typing.Optional[typing.List[VendorSplit]] = OMIT,
    ) -> OrdersEntity:
        _request: typing.Dict[str, typing.Any] = {
            "order_amount": order_amount,
            "order_currency": order_currency,
            "customer_details": customer_details,
        }
        if order_id is not OMIT:
            _request["order_id"] = order_id
        if terminal is not OMIT:
            _request["terminal"] = terminal
        if order_meta is not OMIT:
            _request["order_meta"] = order_meta
        if order_expiry_time is not OMIT:
            _request["order_expiry_time"] = order_expiry_time
        if order_note is not OMIT:
            _request["order_note"] = order_note
        if order_tags is not OMIT:
            _request["order_tags"] = order_tags
        if order_splits is not OMIT:
            _request["order_splits"] = order_splits
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment}/", "orders"),
            json=jsonable_encoder(_request),
            headers=remove_none_from_headers(
                {
                    "x-client-id": self.client_id,
                    "x-client-secret": self.client_secret,
                    "x-api-version": self.api_version,
                }
            ),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(OrdersEntity, _response.json())  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(AuthenticationError, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(RateLimitError, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(types_api_error_ApiError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(status_code=_response.status_code, body=_response.text)
        raise core_api_error_ApiError(status_code=_response.status_code, body=_response_json)

    def order_pay(
        self,
        *,
        payment_session_id: str,
        payment_method: OrderPayRequestPaymentMethod,
        save_instrument: typing.Optional[bool] = OMIT,
        offer_id: typing.Optional[str] = OMIT,
    ) -> OrderPayResponse:
        _request: typing.Dict[str, typing.Any] = {
            "payment_session_id": payment_session_id,
            "payment_method": payment_method,
        }
        if save_instrument is not OMIT:
            _request["save_instrument"] = save_instrument
        if offer_id is not OMIT:
            _request["offer_id"] = offer_id
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment}/", "orders/sessions"),
            json=jsonable_encoder(_request),
            headers=remove_none_from_headers(
                {
                    "x-client-id": self.client_id,
                    "x-client-secret": self.client_secret,
                    "x-api-version": self.api_version,
                }
            ),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(OrderPayResponse, _response.json())  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(RateLimitError, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(types_api_error_ApiError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(status_code=_response.status_code, body=_response.text)
        raise core_api_error_ApiError(status_code=_response.status_code, body=_response_json)

    def preauthorization(
        self,
        order_id: str,
        *,
        action: typing.Optional[AuthorizationRequestAction] = OMIT,
        amount: typing.Optional[float] = OMIT,
    ) -> PaymentsEntity:
        _request: typing.Dict[str, typing.Any] = {}
        if action is not OMIT:
            _request["action"] = action
        if amount is not OMIT:
            _request["amount"] = amount
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment}/", f"orders/{order_id}/authorization"),
            json=jsonable_encoder(_request),
            headers=remove_none_from_headers(
                {
                    "x-client-id": self.client_id,
                    "x-client-secret": self.client_secret,
                    "x-api-version": self.api_version,
                }
            ),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PaymentsEntity, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(status_code=_response.status_code, body=_response.text)
        raise core_api_error_ApiError(status_code=_response.status_code, body=_response_json)

    def get_order(self, order_id: str) -> OrdersEntity:
        _response = httpx.request(
            "GET",
            urllib.parse.urljoin(f"{self._environment}/", f"orders/{order_id}"),
            headers=remove_none_from_headers(
                {
                    "x-client-id": self.client_id,
                    "x-client-secret": self.client_secret,
                    "x-api-version": self.api_version,
                }
            ),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(OrdersEntity, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(status_code=_response.status_code, body=_response.text)
        raise core_api_error_ApiError(status_code=_response.status_code, body=_response_json)


class AsyncOrdersClient:
    def __init__(
        self,
        *,
        environment: str,
        client_id: typing.Optional[str] = None,
        client_secret: typing.Optional[str] = None,
        api_version: typing.Optional[str] = None,
    ):
        self._environment = environment
        self.client_id = client_id
        self.client_secret = client_secret
        self.api_version = api_version

    async def create_order(
        self,
        *,
        order_id: typing.Optional[str] = OMIT,
        order_amount: float,
        order_currency: str,
        customer_details: CustomerDetails,
        terminal: typing.Optional[TerminalDetails] = OMIT,
        order_meta: typing.Optional[OrderMeta] = OMIT,
        order_expiry_time: typing.Optional[str] = OMIT,
        order_note: typing.Optional[str] = OMIT,
        order_tags: typing.Optional[typing.Dict[str, str]] = OMIT,
        order_splits: typing.Optional[typing.List[VendorSplit]] = OMIT,
    ) -> OrdersEntity:
        _request: typing.Dict[str, typing.Any] = {
            "order_amount": order_amount,
            "order_currency": order_currency,
            "customer_details": customer_details,
        }
        if order_id is not OMIT:
            _request["order_id"] = order_id
        if terminal is not OMIT:
            _request["terminal"] = terminal
        if order_meta is not OMIT:
            _request["order_meta"] = order_meta
        if order_expiry_time is not OMIT:
            _request["order_expiry_time"] = order_expiry_time
        if order_note is not OMIT:
            _request["order_note"] = order_note
        if order_tags is not OMIT:
            _request["order_tags"] = order_tags
        if order_splits is not OMIT:
            _request["order_splits"] = order_splits
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment}/", "orders"),
                json=jsonable_encoder(_request),
                headers=remove_none_from_headers(
                    {
                        "x-client-id": self.client_id,
                        "x-client-secret": self.client_secret,
                        "x-api-version": self.api_version,
                    }
                ),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(OrdersEntity, _response.json())  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(AuthenticationError, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(RateLimitError, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(types_api_error_ApiError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(status_code=_response.status_code, body=_response.text)
        raise core_api_error_ApiError(status_code=_response.status_code, body=_response_json)

    async def order_pay(
        self,
        *,
        payment_session_id: str,
        payment_method: OrderPayRequestPaymentMethod,
        save_instrument: typing.Optional[bool] = OMIT,
        offer_id: typing.Optional[str] = OMIT,
    ) -> OrderPayResponse:
        _request: typing.Dict[str, typing.Any] = {
            "payment_session_id": payment_session_id,
            "payment_method": payment_method,
        }
        if save_instrument is not OMIT:
            _request["save_instrument"] = save_instrument
        if offer_id is not OMIT:
            _request["offer_id"] = offer_id
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment}/", "orders/sessions"),
                json=jsonable_encoder(_request),
                headers=remove_none_from_headers(
                    {
                        "x-client-id": self.client_id,
                        "x-client-secret": self.client_secret,
                        "x-api-version": self.api_version,
                    }
                ),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(OrderPayResponse, _response.json())  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(RateLimitError, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(types_api_error_ApiError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(status_code=_response.status_code, body=_response.text)
        raise core_api_error_ApiError(status_code=_response.status_code, body=_response_json)

    async def preauthorization(
        self,
        order_id: str,
        *,
        action: typing.Optional[AuthorizationRequestAction] = OMIT,
        amount: typing.Optional[float] = OMIT,
    ) -> PaymentsEntity:
        _request: typing.Dict[str, typing.Any] = {}
        if action is not OMIT:
            _request["action"] = action
        if amount is not OMIT:
            _request["amount"] = amount
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment}/", f"orders/{order_id}/authorization"),
                json=jsonable_encoder(_request),
                headers=remove_none_from_headers(
                    {
                        "x-client-id": self.client_id,
                        "x-client-secret": self.client_secret,
                        "x-api-version": self.api_version,
                    }
                ),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PaymentsEntity, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(status_code=_response.status_code, body=_response.text)
        raise core_api_error_ApiError(status_code=_response.status_code, body=_response_json)

    async def get_order(self, order_id: str) -> OrdersEntity:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "GET",
                urllib.parse.urljoin(f"{self._environment}/", f"orders/{order_id}"),
                headers=remove_none_from_headers(
                    {
                        "x-client-id": self.client_id,
                        "x-client-secret": self.client_secret,
                        "x-api-version": self.api_version,
                    }
                ),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(OrdersEntity, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(status_code=_response.status_code, body=_response.text)
        raise core_api_error_ApiError(status_code=_response.status_code, body=_response_json)
